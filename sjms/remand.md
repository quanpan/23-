一、总体来说设计模式分为三大类：

创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。

结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。

行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。

二、设计模式的六大原则

1、开闭原则（Open Close Principle）

开闭原则就是说对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。所以一句话概括就是：为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。

2、里氏代换原则（Liskov Substitution Principle）

里氏代换原则(Liskov Substitution Principle LSP)面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。 LSP是继承复用的基石，只有当衍生类可以替换掉基类，软件单位的功能不受到影响时，基类才能真正被复用，而衍生类也能够在基类的基础上增加新的行为。里氏代换原则是对“开-闭”原则的补充。实现“开-闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。—— From Baidu 百科

3、依赖倒转原则（Dependence Inversion Principle）

这个是开闭原则的基础，具体内容：真对接口编程，依赖于抽象而不依赖于具体。

4、接口隔离原则（Interface Segregation Principle）

这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。还是一个降低类之间的耦合度的意思，从这儿我们看出，其实设计模式就是一个软件的设计思想，从大型软件架构出发，为了升级和维护方便。所以上文中多次出现：降低依赖，降低耦合。

5、迪米特法则（最少知道原则）（Demeter Principle）

为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。

6、合成复用原则（Composite Reuse Principle）

原则是尽量使用合成/聚合的方式，而不是使用继承。

1.组合模式：组合对象，成员变量包含其他组合对象  常见场景：二叉树组装
2.模板模式：抽象类继承，调用未实现方法  常见场景：基本业务流程相同，差异节点提供未实现接口，销售服务，场景接口
3.策略模式：多种策略实现同一接口，根据传入策略注入对应的策略类  常见场景：if（）else if() else if()
4.单例模式：公共变量访问锁，避免并发相互干扰
5.抽象工厂：由专门工厂类提供对象实例化， 常见场景：spring bean依赖注入
6.装饰者模式： 注入原接口，在原接口方法中扩展逻辑    类似重写   [=================>++++]
7.代理模式: 注入原接口，提供新的方法在原接口方法外层扩展  类似    [++++++++][===================>][++++++]
8.外观模式：时间点切片，多个协同组件相同时间点执行动作再包装到一个方法中,包装细节
9.观察者模式：发布者在发布内容发生变化时，通知订阅了该发布内容的服务更新发布内容。  配置中心
10.建造者模式：创建最终对象步骤分离 目标对象,组装类,获取类
11.桥接模式:  面向接口，不面向具体实现              interface - Impl 结构   
12：享元模式： 工具类
13.原型模式：深浅复制
14.迭代子模式：循环操作///
15.责任链模式：动态流程处理，if else 分离，过滤器-拦截器
16:状态模式：固定流程    电梯运转，订单流程
17.命令模式：调用者和执行者解耦,中间类作为调用命令传递者,转发  hub4接口层请求转发
18.工厂方法模式：
19.适配器模式：
20.解释器模式：
21.中介者模式：
22.备忘录模式：通过附加类暂存当前类的属性状态,相当于备份。
23.访问者模式：



